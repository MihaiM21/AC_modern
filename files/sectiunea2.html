<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secțiunea II - Formatul instrucțiunilor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <i class="bi bi-mortarboard-fill"></i> Curs 7 - ASI
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Acasă</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="sectiunea1.html">Secțiunea I</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="sectiunea2.html">Secțiunea II</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="sectiunea3.html">Secțiunea III</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Progress Indicator -->
    <div class="progress-indicator">
        <div class="progress-bar-indicator" style="width: 66%"></div>
    </div>

    <!-- Main Content -->
    <div class="content-page">
        <div class="container">
            <div class="row">
                <div class="col-lg-10 mx-auto">
                    <!-- Breadcrumb -->
                    <nav aria-label="breadcrumb" class="mt-4 mb-3">
                        <ol class="breadcrumb">
                            <li class="breadcrumb-item"><a href="index.html">Acasă</a></li>
                            <li class="breadcrumb-item active">Secțiunea II</li>
                        </ol>
                    </nav>

                    <!-- Content Wrapper -->
                    <div class="content-wrapper fade-in-up">
                        <!-- Section Title -->
                        <div class="content-section">
                        
                        <!-- Secțiunea II - Formatul Instrucțiunilor -->
                        <h1 class="display-4 mb-4">II. FORMATUL INSTRUCȚIUNILOR</h1>

                        <p>
                            Formatul instrucțiunilor se reprezintă de obicei în formă grafică sub forma unor dreptunghiuri ce simbolizează câmpurile binare incluse în instrucțiuni. Din punctul de vedere al lungimii instrucțiunilor pot exista două tipuri de ASI:
                        </p>

                        <ul class="mt-3">
                            <li>arhitecturi la care <strong><em>lungimea</em></strong> instrucțiunilor este <strong><em>fixă</em></strong>, pentru tot setul recunoscut</li>
                            <li>arhitecturi cu <strong><em>lungime</em></strong> a instrucțiunilor recunoscute</li>
                        </ul>

                        <p class="mt-3">
                            La microprocesoarele cu lungime fixă a instrucțiunilor (de exemplu arhitecturi RISC<sup>3</sup>, dar și arhitecturi CISC cum ar fi cea a calculatorului Felix C256) unitatea de control, care interpretează instrucțiunile și lansează comenzile pentru executarea lor, este mult mai simplă, dar se ocupă un spațiu mai mare în memorie. Formatul de lungime variabilă a instrucțiunilor (în general microprocesoare cu arhitectură CISC<sup>4</sup>) implică o complexitate mai mare a unității de control. Lungimea variabilă a instrucțiunilor (lungime mică pentru operații simple și mai mare pentru operații complexe) permite programe cu cod mai compact (ocupă în general o zonă mai mică de memorie) și secvențiere permite extinderea ușoară a setului de instrucțiuni, pentru că nu există limitarea unui număr fix de octeți.
                        </p>

                        <p>
                            Instrucțiunile se reprezintă în memorie principală ca octeți succesivi (unul sau mai mulți octeți în funcție de complexitatea instrucțiunilor), având lungime variabilă în funcție de instrucțiuni (de exemplu de 1 până la 15 octeți) sau lungime fixă într-un număr fix de octeți, ce trebuie executată de hardware, operanzi utilizați și locul unde se stochează rezultatul operației). Formatul instrucțiunilor include două tipuri principale de informații:
                        </p>

                        <ul class="mt-3">
                            <li>codul operației (Op-Code în figura 4.2.) pe care o comandă instrucțiunea respectivă</li>
                            <li>câmpuri de adrese pentru specificarea modului de referire la operanzi și la locul unde se stochează rezultatul. Vom numi aceste câmpuri specificatori de operanzi, pentru că ei indica adresa sau modul de calcul al adreselor efective ale operanzilor (în figura 4.2., și la care specificatorii OP1, OP2 și OP3 sunt specificatori de adresă de operanzi: OP1, OP2, OP3).</li>
                        </ul>

                        <div class="text-center mb-3 mt-4">
                            <svg width="600" height="80" xmlns="http://www.w3.org/2000/svg">
                                <!-- Op-Code -->
                                <rect x="50" y="20" width="120" height="40" fill="white" stroke="black" stroke-width="2"/>
                                <text x="110" y="45" text-anchor="middle" font-family="Arial" font-size="14">Op-Code</text>
                                
                                <!-- OP1 -->
                                <rect x="170" y="20" width="100" height="40" fill="white" stroke="black" stroke-width="2"/>
                                <text x="220" y="45" text-anchor="middle" font-family="Arial" font-size="14">OP1</text>
                                
                                <!-- OP2 -->
                                <rect x="270" y="20" width="120" height="40" fill="white" stroke="black" stroke-width="2"/>
                                <text x="330" y="45" text-anchor="middle" font-family="Arial" font-size="14">OP2</text>
                                
                                <!-- OP3 -->
                                <rect x="390" y="20" width="160" height="40" fill="white" stroke="black" stroke-width="2"/>
                                <text x="470" y="45" text-anchor="middle" font-family="Arial" font-size="14">OP3</text>
                            </svg>
                        </div>

                        <p class="fst-italic text-center">
                            <strong>Figura 4.2.</strong> Exemplu al formatului general pentru o instrucțiune ASI
                        </p>

                        <p class="mt-4">
                            Primul câmp binar al instrucțiunii reprezintă codul numeric identificator al instrucțiunii (OpCode = cod al operației efectuate de instrucțiune). Lungimea acestui câmp identifică funcție de complexitatea operației și eventuale informații suplimentare pe care le cuprinde: aceste informații pot fi de exemplu: modul de adresare al operanzilor sursă, un indicator de condiție testat pentru a lua o decizie la execuția instrucțiunii, un prefix al codului operației care modifică modul de lucru al acelei instrucțiuni. Prefixul poate avea efecte diverse, cum ar fi:
                        </p>

                        <ul class="mt-3">
                            <li>repetare de un număr de ori a instrucțiunii cu prefix.</li>
                            <li>indicația că se lucrează cu operanzi sau adrese extinse (dimensiune dublă față de cea normală)</li>
                            <li>identifică o instrucțiune specială destinată coprocesorului aritmetic.</li>
                        </ul>

                        <p class="mt-3">
                            Apoi urmează specificatorii pentru operanzi (modul de găsire al operanzilor se numește <em>mod de adresare</em> al operanzilor). Ordinea în care sunt dispuși specificatorii de operanzi în formatul instrucțiunii diferă de la un procesor la altul. Vom considera, după codul operației cel din figura 4.2., și la care specificatorii OP1 se referă la destinație (acesta ar fi un mod de destinație). Să observăm că pot exista specificatori de operanzi <em>explicit</em> în formatul instrucțiunii după codul operației (s-ar crede că există trei operanzi pentru acest format) sau <em>implicit</em> în codul operației. Vom numi aceste câmpuri specificatori de operanzi, pentru că ei indica adresa sau modul de calcul al adreselor efective ale operanzilor (în figura 4.2., și la care specificatorii OP1 se referă la destinație (acesta ar fi un mod intern al instrucțiunii, iar prin decodarea operației sector vârful instrucțiunii, registrele respective fiind recunoscute <em>implicit</em> ca sursă sau destinație de operanzi).
                        </p>

                        <p>
                            Instrucțiunea recunoscută de mașină este scrisă deci în cod binar care codifică o acțiune a procesorului. Specificatorii de operanzi se apar <em>explicit</em> în formatul instrucțiunii după codul operației și s-ar crede că există două categorii principale, dar prin decodarea operației (s-ar crede că există trei operanzi utilizați în locul unde se stochează rezultatul operației). Formatul instrucțiunilor include două tipuri principale de informații.
                        </p>

                        <p>
                            După modul în care se stochează în memoria principală adresele operanzilor imediați din câmpul de specificatori, există două convenții. Convenția "Little Endian" (aleasă de șirul indian care are în față cel mai puțin semnificativ) plasează întotdeauna pe prima poziție, la adresa cea mai mică, cuvântul cel mai puțin semnificativ (adresa mică), între cuvântul cel mai semnificativ al unei adrese multi - cuvânt. Stocarea în memorie, în convenția "Little Endian", a unui cuvânt de 32 biți. Memoria din figura este organizată pe octet, având deci alocată câte o adresă fiecărui cuvânt de 8 biți. Valorile numerice au fost scrise în hexazecimal.
                        </p>

                        <!-- Conținut despre Big Endian și Little Endian -->
                        <div class="mb-5 mt-5">
                            <img src="fig4.3.png" alt="Figura 4.3: Exemplu de stocare a unui cuvânt de 32 de biți, într-o memorie organizată pe octeți, convenția unităților să aibă preferință" class="img-fluid mb-3 mx-auto d-block">

                            <p class="fst-italic text-center">
                                <strong>Figura 4.3.</strong> Exemplu de stocare a unui cuvânt de 32 de biți, într-o memorie organizată pe octeți, convenția unităților să aibă preferință. Într-o instrucțiune ce adresează pe 32 de biți se va copia octetul cel mai din dreapta în locația adresei "A", unde este stocat octetul cel mai puțin semnificativ.
                            </p>

                            <p class="mt-4">
                                Pentru cealaltă convenție, numită "Big Endian" (mareele indien), ordinea este inversă, adică "în față", la adresa cea mai mică se plasează octetul cel mai semnificativ al cuvântului multi-octet. Legat de convenția de stocare în memorie a informațiilor (instrucțiuni, date, adrese) trebuie menționată și ca la unele microprocesoare accesul în obiecte mai mari decât un octet se poate face doar dacă informația este aliniată. Alinierea se referă la faptul că accesul în obiecte de dimensiunea <em>D</em> octeți se face prin specificarea adresei <em>A</em> primului octet ocupat, unde adresa A respectă ecuația:
                            </p>

                            <p class="text-center mt-3 mb-3">
                                <strong><em>A mod D = 0</em></strong>
                            </p>

                            <p>
                                Considerând o memorie adresabilă la nivel de octeți și un microprocesor de 32 biți, alinierea și realinierea informațiilor în figurile 32 de biți se va simplifica grafic în figura 4.4.
                            </p>

                            <img src="fig4.4.png" alt="Figura 4.4: Exemplu de adrese de acces la obiecte aliniate și nealiniate" class="img-fluid mb-3 mx-auto d-block">

                            <p class="fst-italic text-center">
                                <strong>Figura 4.4.</strong> Exemplu de adrese de acces la obiecte aliniate și nealiniate. Cuvântul de 32 de biți nealiniat poate fi citit în cel mai bun caz prin două accesări succesive la memorie pentru citirea a celor 2 octeți.
                            </p>

                            <p class="mt-4">
                                Nealinierea produce complicații la citirea memoriei și conduce la pierdere de timp. În exemplul din figura 4.4, pentru informația aliniată citirea se poate face într-un singur ciclu de acces la memorie. Pentru informații ne-aliniate trebuiesc cel puțin două cicluri de acces la memorie. Dar atâtă de critică încât ar fi dacă nealinierea s-ar realiza prin stocarea informațiilor pe 32 de biți la adrese succesive, de exemplu în ordinea: 0B, 0C, 0D și 0E hex, când citirea ar trebui făcută pentru fiecare în parte.
                            </p>
                        </div>

                        <hr class="my-4">

                        <p class="small text-muted">
                            <sup>3</sup> RISC = Reduced Instruction Set Computer<br>
                            <sup>4</sup> CISC = Complex Instruction Set Computer
                        </p>

                        <!-- Navigation Buttons -->
                        <div class="d-flex justify-content-between align-items-center mt-5 pt-4 border-top">
                            <a href="sectiunea1.html" class="btn btn-outline-primary btn-lg">
                                <i class="bi bi-arrow-left"></i> Secțiunea I
                            </a>
                            <a href="sectiunea3.html" class="btn btn-primary btn-lg">
                                Următoarea Secțiune <i class="bi bi-arrow-right"></i>
                            </a>
                        </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Back to Top Button -->
    <button class="back-to-top" id="backToTop">
        <i class="bi bi-arrow-up"></i>
    </button>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

